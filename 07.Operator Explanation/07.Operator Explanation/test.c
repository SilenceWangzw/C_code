#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

//一、操作符的分类
//算术操作符: +  -  *  /  %
//移位操作符: <<  >>     --- 移动的是二进制位
//位操作符: &  |  ^      --- 也是使用二进制位进行计算
//赋值操作符: =  +=  -=  *=  /=  %=  <<=  >>=  &=  |=  ^=
//单目操作符: !  ++  --   &  *  +  -  ~  sizeof  (类型)
//关系操作符: >  >=  <  <=  ==  !=
//逻辑操作符: &&  ||
//条件操作符: ?  :
//逗号表达式: ,
//下标引用: []
//函数调用: ()
//结构成员访问: .  ->




//二、原码，反码，补码
//正数的原反补相同
//负数的原反补需要计算
//int main()
//{
//	int a = -10;
//	//1 0000000000000000000000000001010 -- 原码
//	//1 1111111111111111111111111110101 -- 反码
//	//1 1111111111111111111111111110110 -- 补码
//	return 0;
//}
//对整数来说，数据在内存中存储的是二进制的补码


//int main()
//{
//	//1 - 1
//	//1 + (-1)
//	//尝试用原码计算
//	//00000000000000000000000000000001  --  1的原码
//	//10000000000000000000000000000001  --  -1的原码
//	//10000000000000000000000000000010  --  -2//err
//
//	//尝试使用补码
//	//00000000000000000000000000000001  --  1的补码
//	//11111111111111111111111111111111  --  -1的补码
//	//100000000000000000000000000000000  --  丢失最高位，==0
//	return 0;
//}




//三、移位操作符
//  <<  左移操作符
//  >>  右移操作符
//移位操作符的操作数只能是整数
//int main()
//{
//	//左移操作符
//	//移动的是存储在内存中的二进制位
//	//左边抛弃，右边补0
//	int a = 10;
//	int b = a << 1;
//	//00000000000000000000000000001010 -- a的补码
//	//00000000000000000000000000010100 -- b==20
//	printf("a=%d\n", a);
//	printf("b=%d\n", b);
//	return 0;
//}


//int main()
//{
//	int a = -1;
//	int b = a << 1;
//	//11111111111111111111111111111111  --  a的补码
//	//11111111111111111111111111111110  --  b的补码
//	//10000000000000000000000000000001  --  b的反码
//	//10000000000000000000000000000010  --  b的原码 == -2
//	printf("b=%d\n", b);
//	return 0;
//}


//int main()
//{
//	//右移操作符
//	//逻辑右移：左边用0填充，右边丢弃
//	//算术右移：左边用原该值的符号位填充，右边丢弃
//	//右移到底采用算术右移还是逻辑右移是取决于编译器的，通常采用的都是算术右移
//	int a = -10;
//	int b = a >> 1;
//	//11111111111111111111111111110110  --  a的补码
//	//11111111111111111111111111111011  --  b的补码
//	//10000000000000000000000000000100  --  b的反码
//	//10000000000000000000000000000101  --  b的原码  == -5
//	printf("%d\n", b);
//	return 0;
//}




//四、位操作符
// &与   |或   ^异或   ~取反
//int main()
//{
//	int a = 6;
//	int b = -7;
//	int c = a & b;//a和b的补码的二进制位进行运算
//	//00000000000000000000000000000110  --  a的补码
//	//11111111111111111111111111111001  --  b的补码
//	//00000000000000000000000000000000  == 0
//	printf("%d\n", c);
//	return 0;
//}


//int main()
//{
//	int a = 6;
//	int b = -7;
//	int c = a | b;
//	//00000000000000000000000000000110  --  a的补码
//	//11111111111111111111111111111001  --  b的补码
//	//11111111111111111111111111111111  --  c的补码
//	//10000000000000000000000000000000  --  c的反码
//	//10000000000000000000000000000001  --  c的原码 == -1
//	printf("%d\n", c);
//	return 0;
//}


//int main()
//{
//	int a = 6;
//	int b = -7;
//	int c = a ^ b;
//	//00000000000000000000000000000110  --  a的补码
//	//11111111111111111111111111111001  --  b的补码
//	//11111111111111111111111111111111  --  c的补码
//	//10000000000000000000000000000000  --  c的反码
//	//10000000000000000000000000000001  --  c的原码 == -1
//	printf("%d\n", c);
//	return 0;
//}


//int main()
//{
//	int a = 0;
//	//00000000000000000000000000000000  --  a的补码
//	//11111111111111111111111111111111  --  按位取反，补码
//	//10000000000000000000000000000000  --  反码
//	//10000000000000000000000000000001  --  原码 == -1
//	printf("%d\n", ~a);
//	return 0;
//}


//面试题：不能创建临时变量，实现两个整数的交换
//写法1
//int main()
//{
//	int a = 3;
//	int b = 5;
//
//	printf("交换前：a=%d,b=%d\n", a, b);
//	a = a + b;
//	b = a - b;
//	a = a - b;
//	printf("交换后：a=%d,b=%d\n", a, b);
//	return 0;
//}


//写法2
// a^a=0   0^a=a   a^a^b=b   a^b^a=b   异或是支持交换律的
//
//int main()
//{
//	int a = 3;
//	int b = 5;
//
//	printf("交换前：a=%d,b=%d\n", a, b);
//	a = a ^ b;
//	b = a ^ b;  //a^b^b=a
//	a = a ^ b;  //a^b^a=b
//	printf("交换后：a=%d,b=%d\n", a, b);
//	return 0;
//}


//练习：编写代码实现，求一个整数存储在内存中二进制中1的个数
//写法1
//int count_bit_one(unsigned int n)
//{
//	int count = 0;
//	while (n)
//	{
//		if ((n % 2) == 1)
//		{
//			count++;
//		}
//		n = n / 2;
//	}
//	return count;
//}
//写法2
//int count_bit_one(int n)
//{
//	int count = 0;
//	int i = 0;
//	for (i = 0; i < 32; i++)
//	{
//		if (((n >> i) & 1) == 1)
//		{
//			count++;
//		}
//	}
//	return count;
//}
//写法3
int count_bit_one(int n)
{
	int count = 0;
	int i = 0;
	while (n)
	{
		n = n & (n - 1);
		count++;
	}
	return count;
}
int main()
{
	int num = 0;
	scanf("%d", &num);
	int ret = count_bit_one(num);
	printf("%d\n", ret);
	return 0;
}